// Code generated by protoc-gen-kratos-foundation-errors. DO NOT EDIT.

package kratos_foundation_pb

import (
	fmt "fmt"
	errors "github.com/jaggerzhuang1994/kratos-foundation/pkg/errors"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
const _ = errors.SupportPackageIsVersion1

// 成功
func IsUndefined(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	if e == nil {
		return false
	}
	return e.Code == 200 && e.Reason == "UNDEFINED" && e.Metadata != nil && e.Metadata["reason_code"] == "0"
}

// 成功
func ErrorUndefined(formatAndArgs ...any) *errors.Error {
	var format string
	var args []any
	if len(formatAndArgs) > 0 {
		format = formatAndArgs[0].(string)
		args = formatAndArgs[1:]
	} else { // 如果没有传参数，则默认填充注释为错误原因
		format = "成功"
	}
	return errors.New(200, "UNDEFINED", fmt.Sprintf(format, args...)).WithReasonCode(0).WithErrStack(4)
}

// 异常请求
func IsBadRequest(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	if e == nil {
		return false
	}
	return e.Code == 400 && e.Reason == "BAD_REQUEST" && e.Metadata != nil && e.Metadata["reason_code"] == "400"
}

// 异常请求
func ErrorBadRequest(formatAndArgs ...any) *errors.Error {
	var format string
	var args []any
	if len(formatAndArgs) > 0 {
		format = formatAndArgs[0].(string)
		args = formatAndArgs[1:]
	} else { // 如果没有传参数，则默认填充注释为错误原因
		format = "异常请求"
	}
	return errors.New(400, "BAD_REQUEST", fmt.Sprintf(format, args...)).WithReasonCode(400).WithErrStack(4)
}

// 无效身份
func IsUnauthorized(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	if e == nil {
		return false
	}
	return e.Code == 401 && e.Reason == "UNAUTHORIZED" && e.Metadata != nil && e.Metadata["reason_code"] == "401"
}

// 无效身份
func ErrorUnauthorized(formatAndArgs ...any) *errors.Error {
	var format string
	var args []any
	if len(formatAndArgs) > 0 {
		format = formatAndArgs[0].(string)
		args = formatAndArgs[1:]
	} else { // 如果没有传参数，则默认填充注释为错误原因
		format = "无效身份"
	}
	return errors.New(401, "UNAUTHORIZED", fmt.Sprintf(format, args...)).WithReasonCode(401).WithErrStack(4)
}

// 无权限操作
func IsForbidden(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	if e == nil {
		return false
	}
	return e.Code == 403 && e.Reason == "FORBIDDEN" && e.Metadata != nil && e.Metadata["reason_code"] == "403"
}

// 无权限操作
func ErrorForbidden(formatAndArgs ...any) *errors.Error {
	var format string
	var args []any
	if len(formatAndArgs) > 0 {
		format = formatAndArgs[0].(string)
		args = formatAndArgs[1:]
	} else { // 如果没有传参数，则默认填充注释为错误原因
		format = "无权限操作"
	}
	return errors.New(403, "FORBIDDEN", fmt.Sprintf(format, args...)).WithReasonCode(403).WithErrStack(4)
}

// 资源不存在
func IsNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	if e == nil {
		return false
	}
	return e.Code == 404 && e.Reason == "NOT_FOUND" && e.Metadata != nil && e.Metadata["reason_code"] == "404"
}

// 资源不存在
func ErrorNotFound(formatAndArgs ...any) *errors.Error {
	var format string
	var args []any
	if len(formatAndArgs) > 0 {
		format = formatAndArgs[0].(string)
		args = formatAndArgs[1:]
	} else { // 如果没有传参数，则默认填充注释为错误原因
		format = "资源不存在"
	}
	return errors.New(404, "NOT_FOUND", fmt.Sprintf(format, args...)).WithReasonCode(404).WithErrStack(4)
}

// 资源状态冲突
func IsConflict(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	if e == nil {
		return false
	}
	return e.Code == 409 && e.Reason == "CONFLICT" && e.Metadata != nil && e.Metadata["reason_code"] == "409"
}

// 资源状态冲突
func ErrorConflict(formatAndArgs ...any) *errors.Error {
	var format string
	var args []any
	if len(formatAndArgs) > 0 {
		format = formatAndArgs[0].(string)
		args = formatAndArgs[1:]
	} else { // 如果没有传参数，则默认填充注释为错误原因
		format = "资源状态冲突"
	}
	return errors.New(409, "CONFLICT", fmt.Sprintf(format, args...)).WithReasonCode(409).WithErrStack(4)
}

// 请求字段校验不通过
func IsValidator(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	if e == nil {
		return false
	}
	return e.Code == 422 && e.Reason == "VALIDATOR" && e.Metadata != nil && e.Metadata["reason_code"] == "422"
}

// 请求字段校验不通过
func ErrorValidator(formatAndArgs ...any) *errors.Error {
	var format string
	var args []any
	if len(formatAndArgs) > 0 {
		format = formatAndArgs[0].(string)
		args = formatAndArgs[1:]
	} else { // 如果没有传参数，则默认填充注释为错误原因
		format = "请求字段校验不通过"
	}
	return errors.New(422, "VALIDATOR", fmt.Sprintf(format, args...)).WithReasonCode(422).WithErrStack(4)
}

// 请求次数过多
func IsTooManyRequests(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	if e == nil {
		return false
	}
	return e.Code == 429 && e.Reason == "TOO_MANY_REQUESTS" && e.Metadata != nil && e.Metadata["reason_code"] == "429"
}

// 请求次数过多
func ErrorTooManyRequests(formatAndArgs ...any) *errors.Error {
	var format string
	var args []any
	if len(formatAndArgs) > 0 {
		format = formatAndArgs[0].(string)
		args = formatAndArgs[1:]
	} else { // 如果没有传参数，则默认填充注释为错误原因
		format = "请求次数过多"
	}
	return errors.New(429, "TOO_MANY_REQUESTS", fmt.Sprintf(format, args...)).WithReasonCode(429).WithErrStack(4)
}

// client has closed connection
func IsClientDisconnected(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	if e == nil {
		return false
	}
	return e.Code == 499 && e.Reason == "CLIENT_DISCONNECTED" && e.Metadata != nil && e.Metadata["reason_code"] == "499"
}

// client has closed connection
func ErrorClientDisconnected(formatAndArgs ...any) *errors.Error {
	var format string
	var args []any
	if len(formatAndArgs) > 0 {
		format = formatAndArgs[0].(string)
		args = formatAndArgs[1:]
	} else { // 如果没有传参数，则默认填充注释为错误原因
		format = "client has closed connection"
	}
	return errors.New(499, "CLIENT_DISCONNECTED", fmt.Sprintf(format, args...)).WithReasonCode(499).WithErrStack(4)
}

// 服务器错误
func IsInternalServer(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	if e == nil {
		return false
	}
	return e.Code == 500 && e.Reason == "INTERNAL_SERVER" && e.Metadata != nil && e.Metadata["reason_code"] == "500"
}

// 服务器错误
func ErrorInternalServer(formatAndArgs ...any) *errors.Error {
	var format string
	var args []any
	if len(formatAndArgs) > 0 {
		format = formatAndArgs[0].(string)
		args = formatAndArgs[1:]
	} else { // 如果没有传参数，则默认填充注释为错误原因
		format = "服务器错误"
	}
	return errors.New(500, "INTERNAL_SERVER", fmt.Sprintf(format, args...)).WithReasonCode(500).WithErrStack(4)
}

// API 未实现
func IsNotImplemented(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	if e == nil {
		return false
	}
	return e.Code == 501 && e.Reason == "NOT_IMPLEMENTED" && e.Metadata != nil && e.Metadata["reason_code"] == "501"
}

// API 未实现
func ErrorNotImplemented(formatAndArgs ...any) *errors.Error {
	var format string
	var args []any
	if len(formatAndArgs) > 0 {
		format = formatAndArgs[0].(string)
		args = formatAndArgs[1:]
	} else { // 如果没有传参数，则默认填充注释为错误原因
		format = "API 未实现"
	}
	return errors.New(501, "NOT_IMPLEMENTED", fmt.Sprintf(format, args...)).WithReasonCode(501).WithErrStack(4)
}

// 网关转发到下游失败
func IsBadGateway(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	if e == nil {
		return false
	}
	return e.Code == 502 && e.Reason == "BAD_GATEWAY" && e.Metadata != nil && e.Metadata["reason_code"] == "502"
}

// 网关转发到下游失败
func ErrorBadGateway(formatAndArgs ...any) *errors.Error {
	var format string
	var args []any
	if len(formatAndArgs) > 0 {
		format = formatAndArgs[0].(string)
		args = formatAndArgs[1:]
	} else { // 如果没有传参数，则默认填充注释为错误原因
		format = "网关转发到下游失败"
	}
	return errors.New(502, "BAD_GATEWAY", fmt.Sprintf(format, args...)).WithReasonCode(502).WithErrStack(4)
}

// 服务不可用
func IsServiceUnavailable(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	if e == nil {
		return false
	}
	return e.Code == 503 && e.Reason == "SERVICE_UNAVAILABLE" && e.Metadata != nil && e.Metadata["reason_code"] == "503"
}

// 服务不可用
func ErrorServiceUnavailable(formatAndArgs ...any) *errors.Error {
	var format string
	var args []any
	if len(formatAndArgs) > 0 {
		format = formatAndArgs[0].(string)
		args = formatAndArgs[1:]
	} else { // 如果没有传参数，则默认填充注释为错误原因
		format = "服务不可用"
	}
	return errors.New(503, "SERVICE_UNAVAILABLE", fmt.Sprintf(format, args...)).WithReasonCode(503).WithErrStack(4)
}

// 下游响应超时
func IsGatewayTimeout(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	if e == nil {
		return false
	}
	return e.Code == 504 && e.Reason == "GATEWAY_TIMEOUT" && e.Metadata != nil && e.Metadata["reason_code"] == "504"
}

// 下游响应超时
func ErrorGatewayTimeout(formatAndArgs ...any) *errors.Error {
	var format string
	var args []any
	if len(formatAndArgs) > 0 {
		format = formatAndArgs[0].(string)
		args = formatAndArgs[1:]
	} else { // 如果没有传参数，则默认填充注释为错误原因
		format = "下游响应超时"
	}
	return errors.New(504, "GATEWAY_TIMEOUT", fmt.Sprintf(format, args...)).WithReasonCode(504).WithErrStack(4)
}

// 服务器不支持请求中使用的 HTTP 版本
func IsHttpVersionNotSupported(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	if e == nil {
		return false
	}
	return e.Code == 505 && e.Reason == "HTTP_VERSION_NOT_SUPPORTED" && e.Metadata != nil && e.Metadata["reason_code"] == "505"
}

// 服务器不支持请求中使用的 HTTP 版本
func ErrorHttpVersionNotSupported(formatAndArgs ...any) *errors.Error {
	var format string
	var args []any
	if len(formatAndArgs) > 0 {
		format = formatAndArgs[0].(string)
		args = formatAndArgs[1:]
	} else { // 如果没有传参数，则默认填充注释为错误原因
		format = "服务器不支持请求中使用的 HTTP 版本"
	}
	return errors.New(505, "HTTP_VERSION_NOT_SUPPORTED", fmt.Sprintf(format, args...)).WithReasonCode(505).WithErrStack(4)
}

// 网络连接超时
func IsNetworkConnectTimeoutError(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	if e == nil {
		return false
	}
	return e.Code == 599 && e.Reason == "NETWORK_CONNECT_TIMEOUT_ERROR" && e.Metadata != nil && e.Metadata["reason_code"] == "599"
}

// 网络连接超时
func ErrorNetworkConnectTimeoutError(formatAndArgs ...any) *errors.Error {
	var format string
	var args []any
	if len(formatAndArgs) > 0 {
		format = formatAndArgs[0].(string)
		args = formatAndArgs[1:]
	} else { // 如果没有传参数，则默认填充注释为错误原因
		format = "网络连接超时"
	}
	return errors.New(599, "NETWORK_CONNECT_TIMEOUT_ERROR", fmt.Sprintf(format, args...)).WithReasonCode(599).WithErrStack(4)
}
