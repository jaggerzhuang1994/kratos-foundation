package export_package

import (
	"fmt"
	"go/format"
	"go/types"
	"path/filepath"
	"runtime"
	"strings"

	"golang.org/x/tools/go/packages"
)

func ExportPackage(pkgName string, srcPkg string) string {
	_, file, _, _ := runtime.Caller(1)

	cfg := &packages.Config{
		Mode: packages.NeedName |
			packages.NeedTypes |
			packages.NeedSyntax |
			packages.NeedTypesInfo,
	}

	pkgs, err := packages.Load(cfg, pkgName)
	if err != nil {
		panic(err)
	}

	src := strings.Builder{}

	src.WriteString(fmt.Sprintf(`// Code generated by %s; DO NOT EDIT.
package %s

import (
	"%s"
)

`, filepath.Base(filepath.Dir(file))+"/"+filepath.Base(file), srcPkg, pkgName))

	typeList := strings.Builder{}
	funcList := strings.Builder{}
	varList := strings.Builder{}
	constList := strings.Builder{}

	for _, pkg := range pkgs {
		scope := pkg.Types.Scope() // 包级作用域

		for _, name := range scope.Names() {
			// 只看导出的
			if !isExported(name) {
				continue
			}

			obj := scope.Lookup(name)
			switch obj.(type) {
			case *types.TypeName:
				typeList.WriteString(fmt.Sprintf("type %s = %s.%s\n", name, pkg.Name, name))
			case *types.Func:
				funcList.WriteString(fmt.Sprintf("var %s = %s.%s\n", name, pkg.Name, name))
			case *types.Var:
				varList.WriteString(fmt.Sprintf("var %s = %s.%s\n", name, pkg.Name, name))
			case *types.Const:
				constList.WriteString(fmt.Sprintf("var %s = %s.%s\n", name, pkg.Name, name))
			}
		}
	}

	src.WriteString(typeList.String())
	src.WriteString(constList.String())
	src.WriteString(varList.String())
	src.WriteString(funcList.String())

	code, err := format.Source([]byte(src.String()))
	if err != nil {
		panic(src.String())
	}

	return string(code)
}

func isExported(name string) bool {
	// 简单判断首字母是否大写
	r := rune(name[0])
	return r >= 'A' && r <= 'Z'
}
