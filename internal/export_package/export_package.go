// Package export_package 提供自动生成 Go 包导出代码的工具
// 该包通过反射分析指定包的导出类型、函数、变量和常量，自动生成类型别名代码
// 用于简化对外部包的引用，避免直接依赖底层实现包
package export_package

import (
	"fmt"
	"go/format"
	"go/types"
	"path/filepath"
	"runtime"
	"strings"

	"golang.org/x/tools/go/packages"
)

// ExportPackage 分析指定的 Go 包，生成包含所有导出元素的类型别名代码
//
// 参数：
//   - pkgName: 要分析的 Go 包导入路径（如 "github.com/redis/go-redis/v9"）
//   - srcPkg: 生成代码的目标包名（如 "redis"）
//
// 返回：
//   - 格式化后的 Go 源代码字符串
//
// 功能说明：
//   - 扫描目标包的所有导出类型、函数、变量和常量
//   - 生成类型别名声明（type A = pkg.A）
//   - 生成变量别名声明（var A = pkg.A）
//   - 自动格式化生成的代码
//
// 注意：
//   - 该函数通过 runtime.Caller(1) 获取调用者的文件路径，用于生成代码注释
//   - 如果包加载失败或代码格式化失败，会触发 panic
//
// 示例：
//
//	code := ExportPackage("github.com/redis/go-redis/v9", "redis")
//	// 生成类似如下的代码：
//	// type Client = redis.Client
//	// var NewClient = redis.NewClient
func ExportPackage(pkgName string, srcPkg string) string {
	// 获取调用者的文件路径，用于生成代码注释
	_, file, _, _ := runtime.Caller(1)

	// 配置包加载模式：需要包名、类型信息、语法树和类型信息
	cfg := &packages.Config{
		Mode: packages.NeedName |
			packages.NeedTypes |
			packages.NeedSyntax |
			packages.NeedTypesInfo,
	}

	// 加载目标包
	pkgs, err := packages.Load(cfg, pkgName)
	if err != nil {
		panic(err)
	}

	// 构建生成的代码
	src := strings.Builder{}

	// 写入文件头：package 声明和 import
	src.WriteString(fmt.Sprintf(`// Code generated by %s; DO NOT EDIT.
package %s

import (
	"%s"
)

`, filepath.Base(filepath.Dir(file))+"/"+filepath.Base(file), srcPkg, pkgName))

	// 按类型分类收集导出元素
	typeList := strings.Builder{}
	funcList := strings.Builder{}
	varList := strings.Builder{}
	constList := strings.Builder{}

	// 遍历包的所有导出元素
	for _, pkg := range pkgs {
		scope := pkg.Types.Scope() // 获取包级作用域

		for _, name := range scope.Names() {
			// 只处理导出的元素（首字母大写）
			if !isExported(name) {
				continue
			}

			obj := scope.Lookup(name)
			switch obj.(type) {
			case *types.TypeName:
				// 类型别名：type A = pkg.A
				typeList.WriteString(fmt.Sprintf("type %s = %s.%s\n", name, pkg.Name, name))
			case *types.Func:
				// 函数别名：var A = pkg.A（函数在 Go 中是一等公民）
				funcList.WriteString(fmt.Sprintf("var %s = %s.%s\n", name, pkg.Name, name))
			case *types.Var:
				// 变量别名：var A = pkg.A
				varList.WriteString(fmt.Sprintf("var %s = %s.%s\n", name, pkg.Name, name))
			case *types.Const:
				// 常量别名：var A = pkg.A（常量在 Go 中也是变量的一种）
				constList.WriteString(fmt.Sprintf("var %s = %s.%s\n", name, pkg.Name, name))
			}
		}
	}

	// 按照以下顺序写入：类型、常量、变量、函数
	src.WriteString(typeList.String())
	src.WriteString(constList.String())
	src.WriteString(varList.String())
	src.WriteString(funcList.String())

	// 格式化生成的代码
	code, err := format.Source([]byte(src.String()))
	if err != nil {
		// 如果格式化失败，输出原始代码以便调试
		panic(src.String())
	}

	return string(code)
}

// isExported 判断 Go 标识符是否为导出的（首字母大写）
//
// 参数：
//   - name: Go 标识符名称
//
// 返回：
//   - 如果标识符首字母是大写字母 A-Z，返回 true；否则返回 false
func isExported(name string) bool {
	// 通过检查首字符的 Unicode 码点判断是否为大写字母
	r := rune(name[0])
	return r >= 'A' && r <= 'Z'
}
